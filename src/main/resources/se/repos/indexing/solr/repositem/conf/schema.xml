<?xml version="1.0" ?>
<!--

    Copyright (C) 2004-2012 Repos Mjukvara AB

-->
<schema name="repositem" version="1.0">

	<fields>
		<!--
		Unique id per resource including revision
		-->
		<field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" />
		
		<!--
		Solr field 
		-->
		<field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />

		<!--
		Type of item: "commit", "file", "folder". Type affects which fields are expected to exist.
		-->
		<field name="type" type="string" indexed="true" stored="true" multiValued="false" />
		<!--
		True for items and commits that are still head
		-->
		<field name="head" type="boolean" indexed="true" stored="true" multiValued="false" />
		<!--
		For items whose indexing progress is tracked, typically commits. Could be changed to a status field with enum values.
		-->
		<field name="complete" type="boolean" indexed="true" stored="true" multiValued="false" />

		<!-- commit type fields -->
		<field name="revauthor" type="string" indexed="true" stored="true" multiValued="false" />
		<field name="revcomment" type="string" indexed="true" stored="true" multiValued="false" />
		<!-- revprops? -->
		
		<!-- revision for which the index doc is made -->
		<field name="rev"  type="long" indexed="true" stored="true" multiValued="false" />
		<field name="revt" type="date" indexed="true" stored="true" multiValued="false" />
		<!-- commit revision - when the item was last modified (maybe at a different path), can be earlier than rev -->
		<field name="revc"  type="long" indexed="true" stored="true" multiValued="false" />
		<field name="revct" type="date" indexed="true" stored="true" multiValued="false" />
		
		<!-- URL, URI (= logical id?), with rev for historical?, including commits? -->
		<field name="url"       type="string" indexed="true" stored="true" multiValued="false"/>
		<!-- URL at host, encoded (unlike pathfull if we keep that one) -->
		<field name="urlpath"       type="string" indexed="true" stored="true" multiValued="false"/>
		<!-- Logical ID -->
		<field name="urlid"       type="string" indexed="true" stored="true" multiValued="false"/>
		
		<!-- repository name, no slashes -->
		<field name="repo"       type="string" indexed="true" stored="true" multiValued="false"/>
		<!-- repository id including host -->
		<field name="repoid"     type="string" indexed="true" stored="true" multiValued="false"/>
		<!-- parent path -->
		<field name="repoparent" type="string" indexed="true" stored="true" multiValued="false"/>
		<!-- host and optional non-standard port -->
		<field name="repohost"   type="string" indexed="true" stored="true" multiValued="false"/>
		
		<!-- item contents stat in this revision, A/M/D or empty -->
		<field name="pathstat" type="string" indexed="true"  stored="true"  multiValued="false"/>
		<!-- item properties stat in this revision, M or empty -->
		<field name="pathstatprop" type="string" indexed="true"  stored="true"  multiValued="false"/>
		
		<!-- path from repository root, starting with slash -->
		<field name="path"     type="string" indexed="true"  stored="true"  multiValued="false"/>
		<!-- file or folder name -->
		<field name="pathname" type="string" indexed="true"  stored="false" multiValued="false"/>
		<!-- extension, i.e. the part after the last dot -->
		<field name="pathext"  type="string" indexed="true"  stored="false" multiValued="false"/>
		<!-- path in repository up to parent (including for folders), no trailing slash -->
		<field name="pathdir"  type="string" indexed="true"  stored="false" multiValued="false"/>
		<!-- all parent folders -->
		<field name="pathin"   type="string" indexed="true"  stored="false" multiValued="true"/>
		
		<!-- path from server root, URL-encoded?, url-at-host/urlpath? -->
		<field name="pathfull"  type="string" indexed="true"  stored="false" multiValued="false"/>
		<!-- all parent folders from server root -->
		<field name="pathfullin"   type="string" indexed="true"  stored="false" multiValued="true"/>

		<!-- classifies item as belonging to 1+ areas of the file hierarchy, such as "trunk"/"branch"/"tag"/"release"/"translation"/"template" -->
		<field name="patharea" type="string" indexed="true" stored="true" multiValued="true" />
		
		<!-- From fulltext extraction -->
		<field name="text" type="text_general" indexed="true" stored="false" multiValued="false" />
		
		<!-- References, unresolved, including external -->
		<field name="ref" type="string" indexed="true" stored="true" multiValued="true"/>
		<!-- References, resolved to "url" field values, excluding query string and fragments, excluding revisions? -->
		<field name="refurl" type="string" indexed="true" stored="true" multiValued="true"/>
		<!-- References, resolved to "id" field values, internal only, with revisions? -->
		<field name="refid" type="string" indexed="true" stored="true" multiValued="true"/>
		
	</fields>

	<!-- field to use to determine and enforce document uniqueness. -->
	<uniqueKey>id</uniqueKey>

	<!-- field for the QueryParser to use when an explicit fieldname is absent -->
	<defaultSearchField>id</defaultSearchField>

	<!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
	<solrQueryParser defaultOperator="OR" />
	
	<types>
		<fieldtype name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true" />
		<fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0" />
		<fieldType name="date" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
		<fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
	
		<!-- A general text field that has reasonable, generic cross-language defaults: 
			it tokenizes with StandardTokenizer, removes stop words from case-insensitive 
			"stopwords.txt" (empty by default), and down cases. At query time only, it 
			also applies synonyms. -->
		<fieldType name="text_general" class="solr.TextField"
			positionIncrementGap="100">
			<analyzer type="index">
				<tokenizer class="solr.StandardTokenizerFactory" />
				<!-- <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" /> -->
				<filter class="solr.WordDelimiterFilterFactory" />
				<filter class="solr.LowerCaseFilterFactory" />
			</analyzer>
			<analyzer type="query">
				<tokenizer class="solr.StandardTokenizerFactory" />
				<!-- <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" /> -->
				<!-- <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" /> -->
				<filter class="solr.LowerCaseFilterFactory" />
			</analyzer>
		</fieldType>	
	</types>
	
</schema>
